Description: Upstream changes introduced in version 0.43a-1
 This patch has been created by dpkg-source during the package build.
 Here's the last changelog entry, hopefully it gives details on why
 those changes were made:
 .
 sshuttle (0.43a-1) unstable; urgency=low
 .
   * New upstream version with patches from GIT
      - Fixes file descriptors leak after a long run (Closes: 607067)
      - Clear up upstream patches and sync (Closes: 607069)
   * debian/patches:
      - Remove debian-changes-0.42-1
      - Refresh debian-changes-0.42-2
      - Add debian-changes-0.43a-1: changes introduced in the GIT repository after the
        0.43a release
 .
 The person named in the Author field signed this changelog entry.
Author: Javier Fernandez-Sanguino Pen~a <jfs@debian.org>
Bug-Debian: http://bugs.debian.org/607067
Bug-Debian: http://bugs.debian.org/607069

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- sshuttle-0.43a.orig/main.py
+++ sshuttle-0.43a/main.py
@@ -56,8 +56,8 @@ python= specify the name/path of the pyt
 r,remote=  ssh hostname (and optional username) of remote sshuttle server
 x,exclude= exclude this subnet (can be used more than once)
 v,verbose  increase debug message verbosity
-e,ssh-cmd= the command to use to connect to the remote [ssh]
 seed-hosts= with -H, use these hostnames for initial scan (comma-separated)
+noserver   don't use a separate server process (mostly for debugging)
 server     (internal use only)
 firewall   (internal use only)
 hostwatch  (internal use only)
@@ -98,9 +98,9 @@ try:
         else:
             sh = None
         sys.exit(client.main(parse_ipport(opt.listen or '0.0.0.0:0'),
-                             opt.ssh_cmd,
+                             not opt.noserver,
                              remotename,
-                             opt.python,
+                             (opt.python or "python"),
                              sh,
                              opt.auto_nets,
                              parse_subnets(includes),
--- sshuttle-0.43a.orig/README.md
+++ sshuttle-0.43a/README.md
@@ -54,14 +54,8 @@ This is how you use it:
 
  - <tt>./sshuttle -r username@sshserver 0.0.0.0/0 -vv</tt>
 
-(You may be prompted for one or more passwords; first, the
-local password to become root using either sudo or su, and
-then the remote ssh password.  Or you might have sudo and ssh set
-up to not require passwords, in which case you won't be
-prompted at all.)
-
 That's it!  Now your local machine can access the remote network as if you
-were right there.  And if your "client" machine is a router, everyone on
+were right there!  And if your "client" machine is a router, everyone on
 your local network can make connections to your remote network.
 
 You don't need to install sshuttle on the remote server;
--- sshuttle-0.43a.orig/ssh.py
+++ sshuttle-0.43a/ssh.py
@@ -21,35 +21,17 @@ def empackage(z, filename):
     return '%s\n%d\n%s' % (basename,len(content), content)
 
 
-def connect(ssh_cmd, rhostport, python):
+def connect(rhostport, python):
     main_exe = sys.argv[0]
+    l = (rhostport or '').split(':', 1)
+    rhost = l[0]
     portl = []
-
-    rhostIsIPv6 = False
-    if (rhostport or '').count(':') > 1:
-        rhostIsIPv6 = True
-        if rhostport.count(']') or rhostport.count('['):
-            result = rhostport.split(']')
-            rhost = result[0].strip('[')
-            if len(result) > 1:
-                result[1] = result[1].strip(':')
-                if result[1] is not '':
-                    portl = ['-p', str(int(result[1]))]
-        else: # can't disambiguate IPv6 colons and a port number. pass the hostname through.
-            rhost = rhostport
-    else: # IPv4
-        l = (rhostport or '').split(':', 1)
-        rhost = l[0]
-        if len(l) > 1:
-            portl = ['-p', str(int(l[1]))]
+    if len(l) > 1:
+        portl = ['-p', str(int(l[1]))]
 
     if rhost == '-':
         rhost = None
 
-    ipv6flag = []
-    if rhostIsIPv6:
-        ipv6flag = ['-6']
-
     z = zlib.compressobj(1)
     content = readfile('assembler.py')
     content2 = (empackage(z, 'helpers.py') +
@@ -71,14 +53,7 @@ def connect(ssh_cmd, rhostport, python):
     if not rhost:
         argv = [python, '-c', pyscript]
     else:
-        if ssh_cmd:
-            sshl = ssh_cmd.split(' ')
-        else:
-            sshl = ['ssh']
-        argv = (sshl + 
-                portl + 
-                ipv6flag + 
-                [rhost, '--', "'%s' -c '%s'" % (python, pyscript)])
+        argv = ['ssh'] + portl + [rhost, '--', "'%s' -c '%s'" % (python, pyscript)]
     (s1,s2) = socket.socketpair()
     def setup():
         # runs in the child process
--- sshuttle-0.43a.orig/client.py
+++ sshuttle-0.43a/client.py
@@ -31,7 +31,7 @@ class FirewallClient:
                     ['-v'] * (helpers.verbose or 0) +
                     ['--firewall', str(port)])
         argv_tries = [
-            ['sudo', '-p', '[local sudo] Password: '] + argvbase,
+            ['sudo'] + argvbase,
             ['su', '-c', ' '.join(argvbase)],
             argvbase
         ]
@@ -45,12 +45,8 @@ class FirewallClient:
             # run in the child process
             s2.close()
         e = None
-        if os.getuid() == 0:
-            argv_tries = argv_tries[-1:]  # last entry only
         for argv in argv_tries:
             try:
-                if argv[0] == 'su':
-                    sys.stderr.write('[local su] ')
                 self.p = ssubprocess.Popen(argv, stdout=s1, preexec_fn=setup)
                 e = None
                 break
@@ -98,34 +94,35 @@ class FirewallClient:
             raise Fatal('cleanup: %r returned %d' % (self.argv, rv))
 
 
-def _main(listener, fw, ssh_cmd, remotename, python, seed_hosts, auto_nets):
+def _main(listener, fw, use_server, remotename, python, seed_hosts, auto_nets):
     handlers = []
-    if helpers.verbose >= 1:
-        helpers.logprefix = 'c : '
-    else:
-        helpers.logprefix = 'client: '
-    debug1('connecting to server...\n')
-    try:
-        (serverproc, serversock) = ssh.connect(ssh_cmd, remotename, python)
-    except socket.error, e:
-        if e.errno == errno.EPIPE:
-            raise Fatal("failed to establish ssh session")
+    if use_server:
+        if helpers.verbose >= 1:
+            helpers.logprefix = 'c : '
         else:
-            raise
-    mux = Mux(serversock, serversock)
-    handlers.append(mux)
+            helpers.logprefix = 'client: '
+        debug1('connecting to server...\n')
+        try:
+            (serverproc, serversock) = ssh.connect(remotename, python)
+        except socket.error, e:
+            if e.errno == errno.EPIPE:
+                raise Fatal("failed to establish ssh session")
+            else:
+                raise
+        mux = Mux(serversock, serversock)
+        handlers.append(mux)
 
-    expected = 'SSHUTTLE0001'
-    initstring = serversock.recv(len(expected))
-    
-    rv = serverproc.poll()
-    if rv:
-        raise Fatal('server died with error code %d' % rv)
+        expected = 'SSHUTTLE0001'
+        initstring = serversock.recv(len(expected))
         
-    if initstring != expected:
-        raise Fatal('expected server init string %r; got %r'
-                        % (expected, initstring))
-    debug1('connected.\n')
+        rv = serverproc.poll()
+        if rv:
+            raise Fatal('server died with error code %d' % rv)
+            
+        if initstring != expected:
+            raise Fatal('expected server init string %r; got %r'
+                            % (expected, initstring))
+        debug1('connected.\n')
 
     def onroutes(routestr):
         if auto_nets:
@@ -161,9 +158,12 @@ def _main(listener, fw, ssh_cmd, remoten
             debug1("-- ignored: that's my address!\n")
             sock.close()
             return
-        chan = mux.next_channel()
-        mux.send(chan, ssnet.CMD_CONNECT, '%s,%s' % dstip)
-        outwrap = MuxWrapper(mux, chan)
+        if use_server:
+            chan = mux.next_channel()
+            mux.send(chan, ssnet.CMD_CONNECT, '%s,%s' % dstip)
+            outwrap = MuxWrapper(mux, chan)
+        else:
+            outwrap = ssnet.connect_dst(dstip[0], dstip[1])
         handlers.append(Proxy(SockWrapper(sock, sock), outwrap))
     handlers.append(Handler([listener], onaccept))
 
@@ -172,16 +172,18 @@ def _main(listener, fw, ssh_cmd, remoten
         mux.send(0, ssnet.CMD_HOST_REQ, '\n'.join(seed_hosts))
     
     while 1:
-        rv = serverproc.poll()
-        if rv:
-            raise Fatal('server died with error code %d' % rv)
+        if use_server:
+            rv = serverproc.poll()
+            if rv:
+                raise Fatal('server died with error code %d' % rv)
         
         ssnet.runonce(handlers, mux)
-        mux.callback()
-        mux.check_fullness()
+        if use_server:
+            mux.callback()
+            mux.check_fullness()
 
 
-def main(listenip, ssh_cmd, remotename, python, seed_hosts, auto_nets,
+def main(listenip, use_server, remotename, python, seed_hosts, auto_nets,
          subnets_include, subnets_exclude):
     debug1('Starting sshuttle proxy.\n')
     listener = socket.socket()
@@ -212,7 +214,7 @@ def main(listenip, ssh_cmd, remotename,
     fw = FirewallClient(listenip[1], subnets_include, subnets_exclude)
     
     try:
-        return _main(listener, fw, ssh_cmd, remotename,
+        return _main(listener, fw, use_server, remotename,
                      python, seed_hosts, auto_nets)
     finally:
         fw.done()
